name: Temperature Monitor CI/CD

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-django pytest-cov python-dotenv

    - name: Create test environment file
      run: |
        cat > .env << EOF
        SWITCHBOT_TOKEN=test_token_for_ci
        SWITCHBOT_SECRET=test_secret_for_ci
        LIVING_ROOM_MAC=TEST_MAC_001
        BEDROOM_MAC=TEST_MAC_002
        OFFICE_MAC=TEST_MAC_003
        OUTDOOR_MAC=TEST_MAC_004
        TEMPERATURE_INTERVAL=60
        EOF

    - name: Run Django system checks
      run: |
        python manage.py check --settings=temperature.test_settings

    - name: Run migrations check
      run: |
        python manage.py makemigrations --check --dry-run --settings=temperature.test_settings

    - name: Run Django tests
      run: |
        python manage.py test --settings=temperature.test_settings --verbosity=2

    - name: Run pytest with coverage
      run: |
        pytest --cov=homepage --cov=scripts --cov-report=xml --cov-report=term-missing

    - name: Upload coverage to Codecov (if available)
      uses: codecov/codecov-action@v3
      if: matrix.python-version == '3.11'
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  security-scan:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install security tools
      run: |
        pip install safety bandit

    - name: Run safety check
      run: |
        pip install -r requirements.txt
        safety check

    - name: Run bandit security scan
      run: |
        bandit -r homepage/ scripts/ temperature/ -f json -o bandit-report.json || true

    - name: Upload security scan results
      uses: actions/upload-artifact@v3
      with:
        name: security-reports
        path: bandit-report.json
      env:
        NODE_TLS_REJECT_UNAUTHORIZED: 0

  code-quality:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install code quality tools
      run: |
        pip install flake8 black isort mypy
        pip install -r requirements.txt

    - name: Run flake8
      run: |
        flake8 homepage/ scripts/ temperature/ --max-line-length=88 --exclude=migrations

    - name: Check code formatting with black
      run: |
        black --check homepage/ scripts/ temperature/

    - name: Check import sorting with isort
      run: |
        isort --check-only homepage/ scripts/ temperature/

    - name: Run type checking with mypy
      run: |
        mypy homepage/ scripts/ temperature/ --ignore-missing-imports || true

  deploy-staging:
    runs-on: [self-hosted, windows]
    needs: [test, security-scan, code-quality]
    if: |
      contains(github.head_ref, 'feature/') || contains(github.head_ref, 'bugfix/')
    environment:
      name: staging
      url: https://staging.temperature-monitor.example.com
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment variables for staging (Windows)
      shell: pwsh
      run: |
        Write-Output "üîß Setting environment variables for Docker Compose..."
        # Set environment variables for docker-compose to use
        $env:SWITCHBOT_TOKEN = "${{ secrets.SWITCHBOT_TOKEN }}"
        $env:SWITCHBOT_SECRET = "${{ secrets.SWITCHBOT_SECRET }}"
        $env:LIVING_ROOM_MAC = "${{ secrets.LIVING_ROOM_MAC }}"
        $env:BEDROOM_MAC = "${{ secrets.BEDROOM_MAC }}"
        $env:OFFICE_MAC = "${{ secrets.OFFICE_MAC }}"
        $env:OUTDOOR_MAC = "${{ secrets.OUTDOOR_MAC }}"
        $env:TEMPERATURE_INTERVAL = "60"
        $env:ENVIRONMENT = "preprod"
        $env:DATABASE_PATH = "/app/data/db.sqlite3"

        # Export variables for subsequent steps
        echo "SWITCHBOT_TOKEN=${{ secrets.SWITCHBOT_TOKEN }}" >> $env:GITHUB_ENV
        echo "SWITCHBOT_SECRET=${{ secrets.SWITCHBOT_SECRET }}" >> $env:GITHUB_ENV
        echo "LIVING_ROOM_MAC=${{ secrets.LIVING_ROOM_MAC }}" >> $env:GITHUB_ENV
        echo "BEDROOM_MAC=${{ secrets.BEDROOM_MAC }}" >> $env:GITHUB_ENV
        echo "OFFICE_MAC=${{ secrets.OFFICE_MAC }}" >> $env:GITHUB_ENV
        echo "OUTDOOR_MAC=${{ secrets.OUTDOOR_MAC }}" >> $env:GITHUB_ENV
        echo "TEMPERATURE_INTERVAL=60" >> $env:GITHUB_ENV
        echo "ENVIRONMENT=preprod" >> $env:GITHUB_ENV
        echo "DATABASE_PATH=/app/data/db.sqlite3" >> $env:GITHUB_ENV

        Write-Output "‚úÖ Environment variables set successfully"

    - name: Stop existing preprod containers (Windows)
      shell: pwsh
      run: |
        try {
          # Only stop preprod containers, not production
          docker-compose -f ci/docker-compose.preprod.yml down
          Write-Output "‚úÖ Stopped existing preprod containers"
        } catch {
          Write-Output "‚ÑπÔ∏è No existing preprod containers to stop"
        }

    - name: Clean up preprod images (Windows)
      shell: pwsh
      run: |
        try {
          # Remove only preprod-specific images to avoid affecting production
          docker image rm temperate_dashboard_preprod:latest -f 2>$null
          docker image rm temperature-daemon:preprod -f 2>$null
          Write-Output "‚úÖ Cleaned up preprod Docker images"
        } catch {
          Write-Output "‚ÑπÔ∏è Preprod image cleanup completed"
        }

    - name: Deploy to staging (Windows)
      shell: pwsh
      run: |
        Write-Output "üöÄ Deploying to staging environment on Windows host machine"
        docker-compose -f ci/docker-compose.preprod.yml up --build -d

        if ($LASTEXITCODE -eq 0) {
          Write-Output "‚úÖ Docker containers started successfully"
        } else {
          Write-Output "‚ùå Failed to start Docker containers"
          exit 1
        }

    - name: Wait for services to be ready (Windows)
      shell: pwsh
      run: |
        Write-Output "‚è≥ Waiting for services to start..."
        Start-Sleep -Seconds 30
        Write-Output "‚úÖ Wait period completed"

    - name: Health check (Windows)
      shell: pwsh
      run: |
        Write-Output "üîç Checking service health..."

        # Check container status
        docker-compose -f ci/docker-compose.preprod.yml ps

        # Check if Django app is responding
        try {
          $response = Invoke-WebRequest -Uri "http://localhost:7070/" -TimeoutSec 10 -UseBasicParsing
          if ($response.StatusCode -eq 200) {
            Write-Output "‚úÖ Django app is responding on port 7070"
          }
        } catch {
          Write-Output "‚ö†Ô∏è Django app not ready yet: $($_.Exception.Message)"
        }

        # Check daemon container status
        try {
          $daemonStatus = docker-compose -f ci/docker-compose.preprod.yml exec -T temperature-daemon ps aux
          if ($daemonStatus -match "temperature_daemon") {
            Write-Output "‚úÖ Temperature daemon is running"
          } else {
            Write-Output "‚ö†Ô∏è Temperature daemon status unclear"
          }
        } catch {
          Write-Output "‚ö†Ô∏è Could not check daemon status: $($_.Exception.Message)"
        }

        # Check daemon status file if accessible
        try {
          $statusFile = docker-compose -f ci/docker-compose.preprod.yml exec -T temperature-daemon cat /app/data/daemon_status.json 2>$null
          if ($statusFile) {
            Write-Output "‚úÖ Daemon status file accessible"
          }
        } catch {
          Write-Output "‚ÑπÔ∏è Daemon status file check skipped"
        }

        Write-Output "‚úÖ Staging deployment complete on Windows host"
        Write-Output "üåê Access your preprod application at: http://localhost:7070"
        Write-Output "üîí Production application remains unaffected at: http://localhost:7000"

  deploy-production:
    runs-on: [self-hosted, windows]
    needs: [test, security-scan, code-quality]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment variables for production (Windows)
      shell: pwsh
      run: |
        Write-Output "üîß Setting environment variables for Docker Compose..."
        # Set environment variables for docker-compose to use
        $env:SWITCHBOT_TOKEN = "${{ secrets.SWITCHBOT_TOKEN }}"
        $env:SWITCHBOT_SECRET = "${{ secrets.SWITCHBOT_SECRET }}"
        $env:LIVING_ROOM_MAC = "${{ secrets.LIVING_ROOM_MAC }}"
        $env:BEDROOM_MAC = "${{ secrets.BEDROOM_MAC }}"
        $env:OFFICE_MAC = "${{ secrets.OFFICE_MAC }}"
        $env:OUTDOOR_MAC = "${{ secrets.OUTDOOR_MAC }}"
        $env:TEMPERATURE_INTERVAL = "600"
        $env:ENVIRONMENT = "production"
        $env:DATABASE_PATH = "/app/data/db.sqlite3"
        $env:DAEMON_STATUS_FILE = "/app/data/daemon_status.json"
        # Django production settings
        $env:DJANGO_SETTINGS_MODULE = "temperature.production_settings"
        $env:DJANGO_DEBUG = "False"
        $env:DJANGO_ALLOWED_HOSTS = "${{ secrets.DJANGO_ALLOWED_HOSTS }}"

        # Export variables for subsequent steps
        echo "SWITCHBOT_TOKEN=${{ secrets.SWITCHBOT_TOKEN }}" >> $env:GITHUB_ENV
        echo "SWITCHBOT_SECRET=${{ secrets.SWITCHBOT_SECRET }}" >> $env:GITHUB_ENV
        echo "LIVING_ROOM_MAC=${{ secrets.LIVING_ROOM_MAC }}" >> $env:GITHUB_ENV
        echo "BEDROOM_MAC=${{ secrets.BEDROOM_MAC }}" >> $env:GITHUB_ENV
        echo "OFFICE_MAC=${{ secrets.OFFICE_MAC }}" >> $env:GITHUB_ENV
        echo "OUTDOOR_MAC=${{ secrets.OUTDOOR_MAC }}" >> $env:GITHUB_ENV
        echo "TEMPERATURE_INTERVAL=600" >> $env:GITHUB_ENV
        echo "ENVIRONMENT=production" >> $env:GITHUB_ENV
        echo "DATABASE_PATH=/app/data/db.sqlite3" >> $env:GITHUB_ENV
        echo "DAEMON_STATUS_FILE=/app/data/daemon_status.json" >> $env:GITHUB_ENV
        echo "DJANGO_SETTINGS_MODULE=temperature.settings" >> $env:GITHUB_ENV
        echo "DJANGO_DEBUG=False" >> $env:GITHUB_ENV
        echo "DJANGO_ALLOWED_HOSTS=${{ secrets.DJANGO_ALLOWED_HOSTS }}" >> $env:GITHUB_ENV

        Write-Output "‚úÖ Environment variables set successfully"
    - name: Stop existing production containers (Windows)
      shell: pwsh
      run: |
        Write-Output "üõë Stopping existing production Docker containers..."
        try {
          docker-compose -f ci/docker-compose.production.yml down
          Write-Output "‚úÖ Existing production containers stopped"
        } catch {
          Write-Output "‚ÑπÔ∏è No existing production containers to stop"
        }
    - name: Clean up production images (Windows)
      shell: pwsh
      run: |
        Write-Output "üßπ Cleaning up production Docker images..."
        try {
          # Remove only production-specific images to avoid affecting preprod
          docker image rm temperate_dashboard_production:latest -f 2>$null
          docker image rm temperature-daemon:production -f 2>$null
          Write-Output "‚úÖ Production Docker images cleaned up"
        } catch {
          Write-Output "‚ÑπÔ∏è Production image cleanup completed"
        }
    - name: Deploy to production (Windows)
      shell: pwsh
      run: |
        Write-Output "üöÄ Deploying to production environment"
        docker-compose -f ci/docker-compose.production.yml up -d --build
        Write-Output "‚úÖ Deployment to production complete"
    - name: Wait for services to be ready (Windows)
      shell: pwsh
      run: |
        Write-Output "‚è≥ Waiting for services to be ready..."
        Start-Sleep -Seconds 30
        Write-Output "‚úÖ Services are ready"
    - name: Health check (Windows)
      shell: pwsh
      run: |
        Write-Output "ü©∫ Performing health check..."
        # Check container status
        docker-compose -f ci/docker-compose.production.yml ps
        Write-Output "‚úÖ Production deployment complete on Windows host"
        Write-Output "üåê Access your application at: http://localhost:7000"
        # Check if Django app is responding
        try {
          $response = Invoke-WebRequest -Uri "http://localhost:7000/" -TimeoutSec 10 -UseBasicParsing
          if ($response.StatusCode -eq 200) {
            Write-Output "‚úÖ Django app is responding on port 7000"
          }
        } catch {
          Write-Output "‚ö†Ô∏è Django app not ready yet: $($_.Exception.Message)"
        }
        # Check daemon container status
        try {
          $daemonStatus = docker-compose -f ci/docker-compose.production.yml exec -T temperature-daemon ps aux
          if ($daemonStatus -match "temperature_daemon") {
            Write-Output "‚úÖ Temperature daemon is running"
          } else {
            Write-Output "‚ö†Ô∏è Temperature daemon status unclear"
          }
        } catch {
          Write-Output "‚ö†Ô∏è Could not check daemon status: $($_.Exception.Message)"
        }
        # Check daemon status file if accessible
        try {
          $statusFile = docker-compose -f ci/docker-compose.production.yml exec -T temperature-daemon cat /app/data/daemon_status.json 2>$null
          if ($statusFile) {
            Write-Output "‚úÖ Daemon status file accessible"
          }
        } catch {
          Write-Output "‚ÑπÔ∏è Daemon status file check skipped"
        }
        Write-Output "‚úÖ Health check completed"
