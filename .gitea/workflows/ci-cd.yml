name: Temperature Monitor CI/CD

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      deploy_to_production:
        description: "Deploy to production environment"
        required: false
        default: false
        type: boolean
      deployment_reason:
        description: "Reason for manual deployment"
        required: false
        default: "Manual deployment"

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-django pytest-cov python-dotenv

      - name: Create test environment file
        run: |
          cat > .env << EOF
          SWITCHBOT_TOKEN=test_token_for_ci
          SWITCHBOT_SECRET=test_secret_for_ci
          LIVING_ROOM_MAC=TEST_MAC_001
          BEDROOM_MAC=TEST_MAC_002
          OFFICE_MAC=TEST_MAC_003
          OUTDOOR_MAC=TEST_MAC_004
          TEMPERATURE_INTERVAL=60
          EOF

      - name: Run Django system checks
        run: |
          python manage.py check --settings=temperature.test_settings

      - name: Run migrations check
        run: |
          python manage.py makemigrations --check --dry-run --settings=temperature.test_settings

      - name: Run Django tests
        run: |
          python manage.py test --settings=temperature.test_settings --verbosity=2

      - name: Run pytest with coverage
        run: |
          pytest --cov=homepage --cov=scripts --cov-report=xml --cov-report=term-missing

      - name: Upload coverage to Codecov (if available)
        uses: codecov/codecov-action@v3
        if: matrix.python-version == '3.11'
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  security-scan:
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install security tools
        run: |
          pip install safety bandit

      - name: Run safety check
        run: |
          pip install -r requirements.txt
          safety check

      - name: Run bandit security scan
        run: |
          bandit -r homepage/ scripts/ temperature/ -f json -o bandit-report.json || true

      - name: Upload security scan results
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: bandit-report.json
        env:
          NODE_TLS_REJECT_UNAUTHORIZED: 0

  code-quality:
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install code quality tools
        run: |
          pip install flake8 black isort mypy
          pip install -r requirements.txt

      - name: Run flake8
        run: |
          flake8 homepage/ scripts/ temperature/ --max-line-length=88 --exclude=migrations

      - name: Check code formatting with black
        run: |
          black --check homepage/ scripts/ temperature/

      - name: Check import sorting with isort
        run: |
          isort --check-only homepage/ scripts/ temperature/

      - name: Run type checking with mypy
        run: |
          mypy homepage/ scripts/ temperature/ --ignore-missing-imports || true

  deploy-staging:
    runs-on: [self-hosted, windows]
    needs: [test, security-scan, code-quality]
    if: |
      contains(github.head_ref, 'feature/') || contains(github.head_ref, 'bugfix/')
    environment:
      name: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set environment variables for staging (Windows)
        shell: pwsh
        run: |
          Write-Output "üîß Setting environment variables for Docker Compose..."
          # Set environment variables for docker-compose to use
          $env:SWITCHBOT_TOKEN = "${{ secrets.SWITCHBOT_TOKEN }}"
          $env:SWITCHBOT_SECRET = "${{ secrets.SWITCHBOT_SECRET }}"
          $env:LIVING_ROOM_MAC = "${{ secrets.LIVING_ROOM_MAC }}"
          $env:BEDROOM_MAC = "${{ secrets.BEDROOM_MAC }}"
          $env:OFFICE_MAC = "${{ secrets.OFFICE_MAC }}"
          $env:OUTDOOR_MAC = "${{ secrets.OUTDOOR_MAC }}"
          $env:TEMPERATURE_INTERVAL = "60"
          $env:ENVIRONMENT = "preprod"
          $env:DATABASE_PATH = "/app/data/db.sqlite3"

          # Export variables for subsequent steps
          echo "SWITCHBOT_TOKEN=${{ secrets.SWITCHBOT_TOKEN }}" >> $env:GITHUB_ENV
          echo "SWITCHBOT_SECRET=${{ secrets.SWITCHBOT_SECRET }}" >> $env:GITHUB_ENV
          echo "LIVING_ROOM_MAC=${{ secrets.LIVING_ROOM_MAC }}" >> $env:GITHUB_ENV
          echo "BEDROOM_MAC=${{ secrets.BEDROOM_MAC }}" >> $env:GITHUB_ENV
          echo "OFFICE_MAC=${{ secrets.OFFICE_MAC }}" >> $env:GITHUB_ENV
          echo "OUTDOOR_MAC=${{ secrets.OUTDOOR_MAC }}" >> $env:GITHUB_ENV
          echo "TEMPERATURE_INTERVAL=60" >> $env:GITHUB_ENV
          echo "ENVIRONMENT=preprod" >> $env:GITHUB_ENV
          echo "DATABASE_PATH=/app/data/db.sqlite3" >> $env:GITHUB_ENV

          Write-Output "‚úÖ Environment variables set successfully"

      - name: Stop existing preprod containers (Windows)
        shell: pwsh
        run: |
          try {
            # Only stop preprod containers, not production (use explicit project name)
            docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod down
            Write-Output "‚úÖ Stopped existing preprod containers"
          } catch {
            Write-Output "‚ÑπÔ∏è No existing preprod containers to stop"
          }

      - name: Clean up preprod images (Windows)
        shell: pwsh
        run: |
          try {
            Write-Output "üßπ Performing safe preprod image cleanup..."

            # Only remove dangling images (not tagged, not used by any container)
            $danglingImages = docker images -f "dangling=true" -q

            if ($danglingImages) {
              Write-Output "Removing dangling images: $danglingImages"
              docker rmi $danglingImages -f 2>$null
            } else {
              Write-Output "No dangling images found"
            }

            # Only remove preprod-specific build cache (not production)
            docker builder prune -f --filter "until=24h" 2>$null

            # Extra safety: List all running containers to verify production is not affected
            Write-Output "Current running containers after preprod cleanup:"
            docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}" | Where-Object { $_ -match "temperature.*production|temperature_.*prod" } 2>$null || Write-Output "No production containers found (this is expected if production isn't running)"

            Write-Output "‚úÖ Safe preprod cleanup completed (only removed dangling images and old cache)"
          } catch {
            Write-Output "‚ÑπÔ∏è Preprod cleanup completed with warnings: $($_.Exception.Message)"
          }
      - name: Deploy to staging (Windows)
        shell: pwsh
        run: |
          Write-Output "üöÄ Deploying to staging environment on Windows host machine"
          docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod up --build -d

          if ($LASTEXITCODE -eq 0) {
            Write-Output "‚úÖ Docker containers started successfully"
          } else {
            Write-Output "‚ùå Failed to start Docker containers"
            exit 1
          }

      - name: Health check (Windows)
        shell: pwsh
        run: |
          Write-Output "üîç Checking service health..."

          # Check container status
          docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod ps

          # Check if Django app is responding
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:7070/" -TimeoutSec 10 -UseBasicParsing
            if ($response.StatusCode -eq 200) {
              Write-Output "‚úÖ Django app is responding on port 7070"
            }
          } catch {
            Write-Output "‚ö†Ô∏è Django app not ready yet: $($_.Exception.Message)"
          }

          # Check SwitchBot daemon container status
          try {
            $daemonStatus = docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod exec -T temperature-daemon ps aux
            if ($daemonStatus -match "temperature_daemon") {
              Write-Output "‚úÖ SwitchBot temperature daemon is running"
            } else {
              Write-Output "‚ö†Ô∏è SwitchBot temperature daemon status unclear"
            }
          } catch {
            Write-Output "‚ö†Ô∏è Could not check SwitchBot daemon status: $($_.Exception.Message)"
          }

          # Check SwitchBot daemon status file if accessible
          try {
            $statusFile = docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod exec -T temperature-daemon cat /app/data/daemon_status.json 2>$null
            if ($statusFile) {
              Write-Output "‚úÖ SwitchBot daemon status file accessible"
            }
          } catch {
            Write-Output "‚ÑπÔ∏è SwitchBot daemon status file check skipped"
          }

          Write-Output "‚úÖ Staging deployment complete on Windows host"
          Write-Output "üåê Access your preprod application at: http://localhost:7070"
          Write-Output "üîí Production application remains unaffected at: http://localhost:7000"

  deploy-production:
    runs-on: [self-hosted, windows]
    needs: [test, security-scan, code-quality]
    if: |
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_to_production == 'true')
    environment:
      name: production
      url: https://production.temperature-monitor.example.com

    steps:
      - name: Log deployment info
        shell: pwsh
        run: |
          Write-Output "üöÄ Starting Production Deployment"
          Write-Output "üìÖ Deployment Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
          Write-Output "üåø Branch: ${{ github.ref }}"
          Write-Output "üë§ Triggered by: ${{ github.actor }}"

          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            Write-Output "üîß Deployment Type: Manual"
            Write-Output "üí¨ Reason: ${{ github.event.inputs.deployment_reason }}"
          } else {
            Write-Output "üîß Deployment Type: Automatic (main/master branch push)"
          }
          Write-Output "---"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set environment variables for production (Windows)
        shell: pwsh
        run: |
          Write-Output "üîß Setting environment variables for Docker Compose..."
          # Set environment variables for docker-compose to use
          $env:SWITCHBOT_TOKEN = "${{ secrets.SWITCHBOT_TOKEN }}"
          $env:SWITCHBOT_SECRET = "${{ secrets.SWITCHBOT_SECRET }}"
          $env:LIVING_ROOM_MAC = "${{ secrets.LIVING_ROOM_MAC }}"
          $env:BEDROOM_MAC = "${{ secrets.BEDROOM_MAC }}"
          $env:OFFICE_MAC = "${{ secrets.OFFICE_MAC }}"
          $env:OUTDOOR_MAC = "${{ secrets.OUTDOOR_MAC }}"
          $env:TEMPERATURE_INTERVAL = "600"
          $env:ENVIRONMENT = "production"
          $env:DATABASE_PATH = "/app/data/db.sqlite3"
          $env:DAEMON_STATUS_FILE = "/app/data/daemon_status.json"
          $env:GOVEE_STATUS_FILE = "${{ vars.TEMPERATURE_DIR }}\data\govee_status.json"
          $env:GOVEE_PID_FILE = "${{ vars.TEMPERATURE_DIR }}\data\govee_service.pid"
          # Django production settings
          $env:DJANGO_SETTINGS_MODULE = "temperature.production_settings"
          $env:DJANGO_DEBUG = "False"
          $env:DJANGO_ALLOWED_HOSTS = "${{ secrets.DJANGO_ALLOWED_HOSTS }}"
          $env:GOVEE_DJANGO_DB_PATH = "${{ vars.TEMPERATURE_DIR }}\data\db.sqlite3"
          $env:SWITCHBOT_HUB_IP = "${{ secrets.SWITCHBOT_HUB_IP }}"

          # Export variables for subsequent steps
          echo "SWITCHBOT_TOKEN=${{ secrets.SWITCHBOT_TOKEN }}" >> $env:GITHUB_ENV
          echo "SWITCHBOT_SECRET=${{ secrets.SWITCHBOT_SECRET }}" >> $env:GITHUB_ENV
          echo "LIVING_ROOM_MAC=${{ secrets.LIVING_ROOM_MAC }}" >> $env:GITHUB_ENV
          echo "BEDROOM_MAC=${{ secrets.BEDROOM_MAC }}" >> $env:GITHUB_ENV
          echo "OFFICE_MAC=${{ secrets.OFFICE_MAC }}" >> $env:GITHUB_ENV
          echo "OUTDOOR_MAC=${{ secrets.OUTDOOR_MAC }}" >> $env:GITHUB_ENV
          echo "TEMPERATURE_INTERVAL=600" >> $env:GITHUB_ENV
          echo "ENVIRONMENT=production" >> $env:GITHUB_ENV
          echo "DATABASE_PATH=/app/data/db.sqlite3" >> $env:GITHUB_ENV
          echo "DAEMON_STATUS_FILE=/app/data/daemon_status.json" >> $env:GITHUB_ENV
          echo "GOVEE_STATUS_FILE=${{ vars.TEMPERATURE_DIR }}\data\govee_status.json" >> $env:GITHUB_ENV
          echo "GOVEE_PID_FILE=${{ vars.TEMPERATURE_DIR }}\data\govee_service.pid" >> $env:GITHUB_ENV
          echo "DJANGO_SETTINGS_MODULE=temperature.settings" >> $env:GITHUB_ENV
          echo "DJANGO_DEBUG=False" >> $env:GITHUB_ENV
          echo "DJANGO_ALLOWED_HOSTS=${{ secrets.DJANGO_ALLOWED_HOSTS }}" >> $env:GITHUB_ENV
          echo "GOVEE_DJANGO_DB_PATH=${{ vars.TEMPERATURE_DIR }}\data\db.sqlite3" >> $env:GITHUB_ENV
          echo "SWITCHBOT_HUB_IP=${{ secrets.SWITCHBOT_HUB_IP }}" >> $env:GITHUB_ENV

          Write-Output "‚úÖ Environment variables set successfully"
      - name: Stop existing production containers (Windows)
        shell: pwsh
        run: |
          Write-Output "üõë Stopping existing production Docker containers..."
          try {
            docker-compose -f ci/docker-compose.production.yml -p temperature-production down
            Write-Output "‚úÖ Existing production containers stopped"
          } catch {
            Write-Output "‚ÑπÔ∏è No existing production containers to stop"
          }
      - name: Clean up production images (Windows)
        shell: pwsh
        run: |
          Write-Output "üßπ Performing safe production image cleanup..."
          try {
            # Only remove dangling images (not tagged, not used by any container)
            $danglingImages = docker images -f "dangling=true" -q

            if ($danglingImages) {
              Write-Output "Removing dangling images: $danglingImages"
              docker rmi $danglingImages -f 2>$null
            } else {
              Write-Output "No dangling images found"
            }

            # Only remove production-specific build cache (conservative approach)
            docker builder prune -f --filter "until=48h" 2>$null

            # Extra safety: List all running containers to verify preprod is not affected
            Write-Output "Current running containers after production cleanup:"
            docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}" | Where-Object { $_ -match "temperature.*preprod" } 2>$null || Write-Output "No preprod containers found (this is expected during production deployment)"

            Write-Output "‚úÖ Safe production cleanup completed (only removed dangling images and old cache)"
          } catch {
            Write-Output "‚ÑπÔ∏è Production cleanup completed with warnings: $($_.Exception.Message)"
          }
      - name: Deploy to production (Windows)
        shell: pwsh
        run: |
          Write-Output "üöÄ Deploying to production environment"
          docker-compose -f ci/docker-compose.production.yml -p temperature-production up -d --build
          Write-Output "‚úÖ Deployment to production complete"
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Deploy Govee Service Production
        shell: pwsh
        run: |
          # Navigate to the project directory
          Set-Location "${{ vars.TEMPERATURE_DIR }}"

          # Start Govee service with proper detachment
          $pidFile = "${{ vars.TEMPERATURE_DIR }}\govee_service.pid"
          $logFile = "${{ vars.TEMPERATURE_DIR }}\logs\govee_service.log"
          $errorFile = "${{ vars.TEMPERATURE_DIR }}\logs\govee_service_error.log"

          # Ensure logs directory exists
          if (-not (Test-Path "${{ vars.TEMPERATURE_DIR }}\logs")) {
              New-Item -ItemType Directory -Path "${{ vars.TEMPERATURE_DIR }}\logs" -Force
          }

          # Stop existing service if running
          if (Test-Path $pidFile) {
              $existingPid = Get-Content $pidFile -ErrorAction SilentlyContinue
              if ($existingPid -and (Get-Process -Id $existingPid -ErrorAction SilentlyContinue)) {
                  Write-Output "Stopping existing Govee service with PID $existingPid"
                  Stop-Process -Id $existingPid -Force
                  Start-Sleep -Seconds 2
              }
              Remove-Item $pidFile -ErrorAction SilentlyContinue
          }

          # Verify Python is available and service file exists
          Write-Output "Verifying prerequisites..."
          try {
              $pythonVersion = & python.exe --version 2>&1
              Write-Output "Python found: $pythonVersion"
          } catch {
              Write-Output "‚ùå Python not found in PATH"
              exit 1
          }

          if (-not (Test-Path "services/govee_service.py")) {
              Write-Output "‚ùå Govee service file not found: services/govee_service.py"
              exit 1
          }

          Write-Output "Starting Govee service..."
          try {
              # Use simple Start-Process with proper detachment
              $process = Start-Process -FilePath "python.exe" `
                  -ArgumentList "services/govee_service.py" `
                  -WorkingDirectory "${{ vars.TEMPERATURE_DIR }}" `
                  -WindowStyle Hidden `
                  -PassThru `
                  -RedirectStandardOutput $logFile `
                  -RedirectStandardError $errorFile

              if ($process) {
                  # Save PID immediately
                  $process.Id | Out-File $pidFile -Encoding UTF8
                  Write-Output "‚úÖ Govee service started successfully with PID $($process.Id)"
                  Write-Output "Process started and detached successfully"
              } else {
                  Write-Output "‚ùå Failed to start Govee service"
                  exit 1
              }

          } catch {
              Write-Output "‚ùå Error starting Govee service: $($_.Exception.Message)"
              exit 1
          }

          # Brief verification that the process started
          Start-Sleep -Seconds 5
          $savedPid = Get-Content $pidFile -ErrorAction SilentlyContinue
          if ($savedPid -and (Get-Process -Id $savedPid -ErrorAction SilentlyContinue)) {
              Write-Output "‚úÖ Govee service is running successfully with PID $savedPid"

              # Show recent log entries to confirm it's working
              if (Test-Path $logFile) {
                  Write-Output "Recent log entries (last 3):"
                  Get-Content $logFile -Tail 3 -ErrorAction SilentlyContinue | ForEach-Object { Write-Output "  $_" }
              }
          } else {
              Write-Output "‚ö†Ô∏è Govee service verification failed"

              if ($savedPid) {
                  Write-Output "PID $savedPid was saved but process is no longer running"
              } else {
                  Write-Output "No PID found in file $pidFile"
              }

              # Show recent log entries for debugging
              if (Test-Path $logFile) {
                  Write-Output "Recent log entries:"
                  Get-Content $logFile -Tail 5 -ErrorAction SilentlyContinue | ForEach-Object { Write-Output "  $_" }
              }

              if (Test-Path $errorFile) {
                  Write-Output "Recent error log entries:"
                  Get-Content $errorFile -Tail 5 -ErrorAction SilentlyContinue | ForEach-Object { Write-Output "  $_" }
              }

              # Don't exit with error - the service might have started but verification timing issues
              Write-Output "Note: Service may still be starting up. Check logs manually if needed."
          }
      - name: Wait for services to be ready (Windows)
        shell: pwsh
        run: |
          Write-Output "‚è≥ Waiting for services to be ready..."
          Start-Sleep -Seconds 30
          Write-Output "‚úÖ Services are ready"
      - name: Health check (Windows)
        shell: pwsh
        run: |
          Write-Output "ü©∫ Performing health check..."
          # Check container status
          docker-compose -f ci/docker-compose.production.yml -p temperature-production ps
          Write-Output "‚úÖ Production deployment complete on Windows host"
          Write-Output "üåê Access your application at: http://localhost:7000"
          # Check if Django app is responding
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:7000/" -TimeoutSec 10 -UseBasicParsing
            if ($response.StatusCode -eq 200) {
              Write-Output "‚úÖ Django app is responding on port 7000"
            }
          } catch {
            Write-Output "‚ö†Ô∏è Django app not ready yet: $($_.Exception.Message)"
          }
          # Check SwitchBot daemon container status
          try {
            $daemonStatus = docker-compose -f ci/docker-compose.production.yml -p temperature-production exec -T temperature-daemon ps aux
            if ($daemonStatus -match "temperature_daemon") {
              Write-Output "‚úÖ SwitchBot temperature daemon is running"
            } else {
              Write-Output "‚ö†Ô∏è SwitchBot temperature daemon status unclear"
            }
          } catch {
            Write-Output "‚ö†Ô∏è Could not check SwitchBot daemon status: $($_.Exception.Message)"
          }

          # Check SwitchBot daemon status file if accessible
          try {
            $statusFile = docker-compose -f ci/docker-compose.production.yml -p temperature-production exec -T temperature-daemon cat /app/data/daemon_status.json 2>$null
            if ($statusFile) {
              Write-Output "‚úÖ SwitchBot daemon status file accessible"
            }
          } catch {
            Write-Output "‚ÑπÔ∏è SwitchBot daemon status file check skipped"
          }
