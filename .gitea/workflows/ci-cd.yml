name: Temperature Monitor CI/CD

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-django pytest-cov python-dotenv

      - name: Create test environment file
        run: |
          cat > .env << EOF
          SWITCHBOT_TOKEN=test_token_for_ci
          SWITCHBOT_SECRET=test_secret_for_ci
          LIVING_ROOM_MAC=TEST_MAC_001
          BEDROOM_MAC=TEST_MAC_002
          OFFICE_MAC=TEST_MAC_003
          OUTDOOR_MAC=TEST_MAC_004
          TEMPERATURE_INTERVAL=60
          EOF

      - name: Run Django system checks
        run: |
          python manage.py check --settings=temperature.test_settings

      - name: Run migrations check
        run: |
          python manage.py makemigrations --check --dry-run --settings=temperature.test_settings

      - name: Run Django tests
        run: |
          python manage.py test --settings=temperature.test_settings --verbosity=2

      - name: Run pytest with coverage
        run: |
          pytest --cov=homepage --cov=scripts --cov-report=xml --cov-report=term-missing

      - name: Upload coverage to Codecov (if available)
        uses: codecov/codecov-action@v3
        if: matrix.python-version == '3.11'
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

  security-scan:
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install security tools
        run: |
          pip install safety bandit

      - name: Run safety check
        run: |
          pip install -r requirements.txt
          safety check

      - name: Run bandit security scan
        run: |
          bandit -r homepage/ scripts/ temperature/ -f json -o bandit-report.json || true

      - name: Upload security scan results
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: bandit-report.json
        env:
          NODE_TLS_REJECT_UNAUTHORIZED: 0

  code-quality:
    runs-on: ubuntu-latest
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install code quality tools
        run: |
          pip install flake8 black isort mypy
          pip install -r requirements.txt

      - name: Run flake8
        run: |
          flake8 homepage/ scripts/ temperature/ --max-line-length=88 --exclude=migrations

      - name: Check code formatting with black
        run: |
          black --check homepage/ scripts/ temperature/

      - name: Check import sorting with isort
        run: |
          isort --check-only homepage/ scripts/ temperature/

      - name: Run type checking with mypy
        run: |
          mypy homepage/ scripts/ temperature/ --ignore-missing-imports || true

  deploy-staging:
    runs-on: [self-hosted, windows]
    needs: [test, security-scan, code-quality]
    if: |
      contains(github.head_ref, 'feature/') || contains(github.head_ref, 'bugfix/')
    environment:
      name: staging
      url: https://staging.temperature-monitor.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables for staging (Windows)
        shell: pwsh
        run: |
          Write-Output "üîß Setting environment variables for Docker Compose..."
          # Set environment variables for docker-compose to use
          $env:SWITCHBOT_TOKEN = "${{ secrets.SWITCHBOT_TOKEN }}"
          $env:SWITCHBOT_SECRET = "${{ secrets.SWITCHBOT_SECRET }}"
          $env:LIVING_ROOM_MAC = "${{ secrets.LIVING_ROOM_MAC }}"
          $env:BEDROOM_MAC = "${{ secrets.BEDROOM_MAC }}"
          $env:OFFICE_MAC = "${{ secrets.OFFICE_MAC }}"
          $env:OUTDOOR_MAC = "${{ secrets.OUTDOOR_MAC }}"
          $env:TEMPERATURE_INTERVAL = "60"
          $env:ENVIRONMENT = "preprod"
          $env:DATABASE_PATH = "/app/data/db.sqlite3"

          # Export variables for subsequent steps
          echo "SWITCHBOT_TOKEN=${{ secrets.SWITCHBOT_TOKEN }}" >> $env:GITHUB_ENV
          echo "SWITCHBOT_SECRET=${{ secrets.SWITCHBOT_SECRET }}" >> $env:GITHUB_ENV
          echo "LIVING_ROOM_MAC=${{ secrets.LIVING_ROOM_MAC }}" >> $env:GITHUB_ENV
          echo "BEDROOM_MAC=${{ secrets.BEDROOM_MAC }}" >> $env:GITHUB_ENV
          echo "OFFICE_MAC=${{ secrets.OFFICE_MAC }}" >> $env:GITHUB_ENV
          echo "OUTDOOR_MAC=${{ secrets.OUTDOOR_MAC }}" >> $env:GITHUB_ENV
          echo "TEMPERATURE_INTERVAL=60" >> $env:GITHUB_ENV
          echo "ENVIRONMENT=preprod" >> $env:GITHUB_ENV
          echo "DATABASE_PATH=/app/data/db.sqlite3" >> $env:GITHUB_ENV

          Write-Output "‚úÖ Environment variables set successfully"

      - name: Stop existing preprod containers (Windows)
        shell: pwsh
        run: |
          try {
            # Only stop preprod containers, not production (use explicit project name)
            docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod down
            Write-Output "‚úÖ Stopped existing preprod containers"
          } catch {
            Write-Output "‚ÑπÔ∏è No existing preprod containers to stop"
          }

      - name: Clean up preprod images (Windows)
        shell: pwsh
        run: |
          try {
            Write-Output "üßπ Performing safe preprod image cleanup..."

            # Only remove dangling images (not tagged, not used by any container)
            $danglingImages = docker images -f "dangling=true" -q

            if ($danglingImages) {
              Write-Output "Removing dangling images: $danglingImages"
              docker rmi $danglingImages -f 2>$null
            } else {
              Write-Output "No dangling images found"
            }

            # Only remove preprod-specific build cache (not production)
            docker builder prune -f --filter "until=24h" 2>$null

            # Extra safety: List all running containers to verify production is not affected
            Write-Output "Current running containers after preprod cleanup:"
            docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}" | Where-Object { $_ -match "temperature.*production|temperature_.*prod" } 2>$null || Write-Output "No production containers found (this is expected if production isn't running)"

            Write-Output "‚úÖ Safe preprod cleanup completed (only removed dangling images and old cache)"
          } catch {
            Write-Output "‚ÑπÔ∏è Preprod cleanup completed with warnings: $($_.Exception.Message)"
          }

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Deploy Govee Service
        shell: pwsh
        run: |
          # Start Govee service
          try {
            Write-Output "‚õî Stop any existing Govee daemon jobs..."
            Get-Job -Name "govee_service" -ErrorAction SilentlyContinue | Stop-Job
            Remove-Job -Name "govee_service" -ErrorAction SilentlyContinue

            Write-Output "üöÄ Starting Govee daemon service..."
            $Env:DATABASE_PATH = "${{ secrets.PREPROD_DB_PATH }}"
            Start-Job -ScriptBlock { python services\govee_service.py } -Name "govee_service"
            Start-Sleep -Seconds 5
            Write-Output "‚úÖ Govee daemon service started"
          } catch {
            Write-Output "‚ö†Ô∏è Could not start Govee daemon service: $($_.Exception.Message)"
          }

          # Check for Govee host service status file
          if (Test-Path "logs\govee_status.json") {
            Write-Output "‚úÖ Govee host service status file found"
            try {
              $goveeStatus = Get-Content "logs\govee_status.json" | ConvertFrom-Json
              if ($goveeStatus.running) {
                Write-Output "‚úÖ Govee host service is running"
              } else {
                Write-Output "‚ö†Ô∏è Govee host service appears stopped"
              }
            } catch {
              Write-Output "‚ÑπÔ∏è Could not parse Govee status file"
            }
          } else {
            Write-Output "‚ÑπÔ∏è Govee host service not running (start with: python services\govee_service.py)"
          }

      - name: Deploy to staging (Windows)
        shell: pwsh
        run: |
          Write-Output "üöÄ Deploying to staging environment on Windows host machine"
          docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod up --build -d

          if ($LASTEXITCODE -eq 0) {
            Write-Output "‚úÖ Docker containers started successfully"
          } else {
            Write-Output "‚ùå Failed to start Docker containers"
            exit 1
          }

      - name: Wait for services to be ready (Windows)
        shell: pwsh
        run: |
          Write-Output "‚è≥ Waiting for services to start..."
          Start-Sleep -Seconds 30
          Write-Output "‚úÖ Wait period completed"

      - name: Health check (Windows)
        shell: pwsh
        run: |
          Write-Output "üîç Checking service health..."

          # Check container status
          docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod ps

          # Check if Django app is responding
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:7070/" -TimeoutSec 10 -UseBasicParsing
            if ($response.StatusCode -eq 200) {
              Write-Output "‚úÖ Django app is responding on port 7070"
            }
          } catch {
            Write-Output "‚ö†Ô∏è Django app not ready yet: $($_.Exception.Message)"
          }

          # Check SwitchBot daemon container status
          try {
            $daemonStatus = docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod exec -T temperature-daemon ps aux
            if ($daemonStatus -match "temperature_daemon") {
              Write-Output "‚úÖ SwitchBot temperature daemon is running"
            } else {
              Write-Output "‚ö†Ô∏è SwitchBot temperature daemon status unclear"
            }
          } catch {
            Write-Output "‚ö†Ô∏è Could not check SwitchBot daemon status: $($_.Exception.Message)"
          }

          # Check SwitchBot daemon status file if accessible
          try {
            $statusFile = docker-compose -f ci/docker-compose.preprod.yml -p temperature-preprod exec -T temperature-daemon cat /app/data/daemon_status.json 2>$null
            if ($statusFile) {
              Write-Output "‚úÖ SwitchBot daemon status file accessible"
            }
          } catch {
            Write-Output "‚ÑπÔ∏è SwitchBot daemon status file check skipped"
          }

          Write-Output "‚úÖ Staging deployment complete on Windows host"
          Write-Output "üåê Access your preprod application at: http://localhost:7070"
          Write-Output "üîí Production application remains unaffected at: http://localhost:7000"

  deploy-production:
    runs-on: [self-hosted, windows]
    needs: [test, security-scan, code-quality]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set environment variables for production (Windows)
        shell: pwsh
        run: |
          Write-Output "üîß Setting environment variables for Docker Compose..."
          # Set environment variables for docker-compose to use
          $env:SWITCHBOT_TOKEN = "${{ secrets.SWITCHBOT_TOKEN }}"
          $env:SWITCHBOT_SECRET = "${{ secrets.SWITCHBOT_SECRET }}"
          $env:LIVING_ROOM_MAC = "${{ secrets.LIVING_ROOM_MAC }}"
          $env:BEDROOM_MAC = "${{ secrets.BEDROOM_MAC }}"
          $env:OFFICE_MAC = "${{ secrets.OFFICE_MAC }}"
          $env:OUTDOOR_MAC = "${{ secrets.OUTDOOR_MAC }}"
          $env:TEMPERATURE_INTERVAL = "600"
          $env:ENVIRONMENT = "production"
          $env:DATABASE_PATH = "/app/data/db.sqlite3"
          $env:DAEMON_STATUS_FILE = "/app/data/daemon_status.json"
          # Django production settings
          $env:DJANGO_SETTINGS_MODULE = "temperature.production_settings"
          $env:DJANGO_DEBUG = "False"
          $env:DJANGO_ALLOWED_HOSTS = "${{ secrets.DJANGO_ALLOWED_HOSTS }}"

          # Export variables for subsequent steps
          echo "SWITCHBOT_TOKEN=${{ secrets.SWITCHBOT_TOKEN }}" >> $env:GITHUB_ENV
          echo "SWITCHBOT_SECRET=${{ secrets.SWITCHBOT_SECRET }}" >> $env:GITHUB_ENV
          echo "LIVING_ROOM_MAC=${{ secrets.LIVING_ROOM_MAC }}" >> $env:GITHUB_ENV
          echo "BEDROOM_MAC=${{ secrets.BEDROOM_MAC }}" >> $env:GITHUB_ENV
          echo "OFFICE_MAC=${{ secrets.OFFICE_MAC }}" >> $env:GITHUB_ENV
          echo "OUTDOOR_MAC=${{ secrets.OUTDOOR_MAC }}" >> $env:GITHUB_ENV
          echo "TEMPERATURE_INTERVAL=600" >> $env:GITHUB_ENV
          echo "ENVIRONMENT=production" >> $env:GITHUB_ENV
          echo "DATABASE_PATH=/app/data/db.sqlite3" >> $env:GITHUB_ENV
          echo "DAEMON_STATUS_FILE=/app/data/daemon_status.json" >> $env:GITHUB_ENV
          echo "GOVEE_STATUS_FILE=/app/data/govee_status.json" >> $env:GITHUB_ENV
          echo "DJANGO_SETTINGS_MODULE=temperature.settings" >> $env:GITHUB_ENV
          echo "DJANGO_DEBUG=False" >> $env:GITHUB_ENV
          echo "DJANGO_ALLOWED_HOSTS=${{ secrets.DJANGO_ALLOWED_HOSTS }}" >> $env:GITHUB_ENV

          Write-Output "‚úÖ Environment variables set successfully"
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Deploy Govee Service
        shell: pwsh
        run: |
          # Start Govee service
          $pidFile = "C:\Temp\govee_service.pid"

          if (Test-Path $pidFile) {
              $existingPid = Get-Content $pidFile
              if (Get-Process -Id $existingPid -ErrorAction SilentlyContinue) {
                  Write-Output "Script already running. Stopping existing instance with PID $existingPid"
                  Stop-Process -Id $existingPid -Force
                  exit
              }
          }
          $process = Start-Process -FilePath "python.exe" -ArgumentList "services/govee_service.py" -PassThru
          $process.Id | Out-File $pidFile
      - name: Stop existing production containers (Windows)
        shell: pwsh
        run: |
          Write-Output "üõë Stopping existing production Docker containers..."
          try {
            docker-compose -f ci/docker-compose.production.yml -p temperature-production down
            Write-Output "‚úÖ Existing production containers stopped"
          } catch {
            Write-Output "‚ÑπÔ∏è No existing production containers to stop"
          }
      - name: Clean up production images (Windows)
        shell: pwsh
        run: |
          Write-Output "üßπ Performing safe production image cleanup..."
          try {
            # Only remove dangling images (not tagged, not used by any container)
            $danglingImages = docker images -f "dangling=true" -q

            if ($danglingImages) {
              Write-Output "Removing dangling images: $danglingImages"
              docker rmi $danglingImages -f 2>$null
            } else {
              Write-Output "No dangling images found"
            }

            # Only remove production-specific build cache (conservative approach)
            docker builder prune -f --filter "until=48h" 2>$null

            # Extra safety: List all running containers to verify preprod is not affected
            Write-Output "Current running containers after production cleanup:"
            docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}" | Where-Object { $_ -match "temperature.*preprod" } 2>$null || Write-Output "No preprod containers found (this is expected during production deployment)"

            Write-Output "‚úÖ Safe production cleanup completed (only removed dangling images and old cache)"
          } catch {
            Write-Output "‚ÑπÔ∏è Production cleanup completed with warnings: $($_.Exception.Message)"
          }
      - name: Deploy to production (Windows)
        shell: pwsh
        run: |
          Write-Output "üöÄ Deploying to production environment"
          docker-compose -f ci/docker-compose.production.yml -p temperature-production up -d --build
          Write-Output "‚úÖ Deployment to production complete"
      - name: Wait for services to be ready (Windows)
        shell: pwsh
        run: |
          Write-Output "‚è≥ Waiting for services to be ready..."
          Start-Sleep -Seconds 30
          Write-Output "‚úÖ Services are ready"
      - name: Health check (Windows)
        shell: pwsh
        run: |
          Write-Output "ü©∫ Performing health check..."
          # Check container status
          docker-compose -f ci/docker-compose.production.yml -p temperature-production ps
          Write-Output "‚úÖ Production deployment complete on Windows host"
          Write-Output "üåê Access your application at: http://localhost:7000"
          # Check if Django app is responding
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:7000/" -TimeoutSec 10 -UseBasicParsing
            if ($response.StatusCode -eq 200) {
              Write-Output "‚úÖ Django app is responding on port 7000"
            }
          } catch {
            Write-Output "‚ö†Ô∏è Django app not ready yet: $($_.Exception.Message)"
          }
          # Check SwitchBot daemon container status
          try {
            $daemonStatus = docker-compose -f ci/docker-compose.production.yml -p temperature-production exec -T temperature-daemon ps aux
            if ($daemonStatus -match "temperature_daemon") {
              Write-Output "‚úÖ SwitchBot temperature daemon is running"
            } else {
              Write-Output "‚ö†Ô∏è SwitchBot temperature daemon status unclear"
            }
          } catch {
            Write-Output "‚ö†Ô∏è Could not check SwitchBot daemon status: $($_.Exception.Message)"
          }

          # Check SwitchBot daemon status file if accessible
          try {
            $statusFile = docker-compose -f ci/docker-compose.production.yml -p temperature-production exec -T temperature-daemon cat /app/data/daemon_status.json 2>$null
            if ($statusFile) {
              Write-Output "‚úÖ SwitchBot daemon status file accessible"
            }
          } catch {
            Write-Output "‚ÑπÔ∏è SwitchBot daemon status file check skipped"
          }

          # Check for Govee host service status file
          if (Test-Path "logs\govee_status.json") {
            Write-Output "‚úÖ Govee host service status file found"
            try {
              $goveeStatus = Get-Content "logs\govee_status.json" | ConvertFrom-Json
              if ($goveeStatus.running) {
                Write-Output "‚úÖ Govee host service is running in production"
              } else {
                Write-Output "‚ö†Ô∏è Govee host service appears stopped"
              }
            } catch {
              Write-Output "‚ÑπÔ∏è Could not parse Govee status file"
            }
          } else {
            Write-Output "‚ÑπÔ∏è Govee host service not running"
            Write-Output "üí° Start Govee service with: start_govee_service.bat"
          }
          Write-Output "‚úÖ Health check completed"
